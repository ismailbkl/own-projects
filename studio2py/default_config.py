#!/usr/bin/env python
# -*- coding: utf8 -*-

import logging

try:
    import autopep8
except ImportError:
    logging.error('''
    Module autopep8 not installed.
    Try : sudo pip install autopep8
    ''')

PYTHON_HEADER = '''# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
# (C) 2019 Smile (<http://www.smile.eu>)
# License AGPL-3.0 or later (https://www.gnu.org/licenses/agpl).
'''

PYTHON_HEADER_CLASS = PYTHON_HEADER + '''
from odoo import fields, models, api
'''

PYTHON_HEADER_MANIFEST = PYTHON_HEADER + '''
##########################################################################
# This module is generated by Odoo Studio and converted By Smile Studio2Py
##### You have to add a name, summary and description to this module #####
##########################################################################
'''

PYTHON_FOOTER = ""

XML_HEADER = '''<?xml version="1.0" encoding="utf-8"?>
<odoo>
'''

XML_FOOTER = '</odoo>'

# Class used to generate python code of each odoo orm object
template_field = ['string', 'help', 'readonly', 'required',
                  'index', 'default', 'states', 'groups',
                  'copy', 'oldname']

template_compute = ['compute', 'inverse', 'search',
                    'store', 'compute_sudo']

template_char = ['size', 'translate']


class OrmTemplate:

    def generate_compute_function(self, field):
        function_content = False
        if field.get('compute'):
            function_content = '    def _compute%s(self):\n %s' % (field['name'],
                                                                   field['compute'].replace('\n', '\n        '))
        return autopep8.fix_code(function_content)

    def parse_dict_field(self, field):
        POP_ITEM = ['ttype', 'state', 'model']
        field_args = []
        field_filtered = dict(filter(lambda item: item[1] is not None, field.items()))
        for key, value in field_filtered.items():
            if key not in POP_ITEM:
                try:
                    if key == 'selection':
                        # import pdb; pdb.set_trace()
                        field_args.append(key + '=' + value.replace('\"', '\'').replace('\"', ''))
                    else:
                        field_args.append(key.replace('field_description', 'string') + '= "' +
                                          value.replace('\"', '\'') + '"')
                except Exception:
                    if key == 'compute':
                        field_args.append(key + "='_compute%s'" % field.get('name'))
        params_args = ""

        for i in field_args:
            params_args += i + ", "
        return params_args

    def generate_python_class_declaration(self, name):
        if name[:2] != 'x_':
            class_syntax = 'class %s(models.Model): \n' % name.title().replace('.', '').replace('_', '')
            class_syntax += ('    _inherit = "%s" \n    ' % name)
        else:
            class_syntax = 'class %s(models.Model): \n' % name.title().replace('X_', '').replace('.', '')
            class_syntax += ('    _name = "%s" \n' % name)
            class_syntax += ("    _inherit = ['mail.thread']\n")

        return class_syntax

    def boolean(self, field):
        declaration_field = "%s = fields.Boolean(%s)" % (field['name'], self.parse_dict_field(field))
        return declaration_field

    def integer(self, field):
        declaration_field = "%s = fields.Integer(%s)" % (field['name'], self.parse_dict_field(field))
        return declaration_field

    def float(self, field):
        declaration_field = "%s = fields.Float(%s)" % (field['name'], self.parse_dict_field(field))
        return declaration_field

    # Supported on Odoo V11 and latest
    def monetary(self, field):
        declaration_field = "%s = fields.Monetary(%s)" % (field['name'], self.parse_dict_field(field))
        return declaration_field

    def char(self, field):
        declaration_field = "%s = fields.Char(%s)" % (field['name'], self.parse_dict_field(field))
        return declaration_field

    def text(self, field):
        declaration_field = "%s = fields.Text(%s)" % (field['name'], self.parse_dict_field(field))
        return declaration_field

    def html(self, field):
        declaration_field = "%s = fields.Html(%s)" % (field['name'], self.parse_dict_field(field))
        return declaration_field

    def date(self, field):
        declaration_field = "%s = fields.Date(%s)" % (field['name'], self.parse_dict_field(field))
        return declaration_field

    def datetime(self, field):
        declaration_field = "%s = fields.Datetime(%s)" % (field['name'], self.parse_dict_field(field))
        return declaration_field

    def binary(self, field):
        declaration_field = "%s = fields.Binary(%s)" % (field['name'], self.parse_dict_field(field))
        return declaration_field

    def selection(self, field):
        # import pdb; pdb.set_trace()
        field['selection'] = field['selection'].replace('[', '(').replace(']', ')')
        selection = list(field['selection'])
        selection[0] = '['
        selection[-1] = ']'
        field['selection'] = ''.join(selection)
        declaration_field = "%s = fields.Selection(%s)" % (field['name'], self.parse_dict_field(field))
        return declaration_field

    def reference(self, field):
        declaration_field = "%s = fields.Reference(%s)" % (field['name'], self.parse_dict_field(field))
        return declaration_field

    def many2one(self, field):
        field['comodel_name'] = field.pop('relation')
        declaration_field = "%s = fields.Many2one(%s)" % (field['name'], self.parse_dict_field(field))
        return declaration_field

    def one2many(self, field):
        field['comodel_name'] = field.pop('relation')
        field['inverse_name'] = field.pop('relation_field')
        declaration_field = "%s = fields.One2many(%s)" % (field['name'], self.parse_dict_field(field))
        return declaration_field

    def many2many(self, field):
        field['comodel_name'] = field.pop('relation')
        declaration_field = "%s = fields.Many2many(%s)" % (field['name'], self.parse_dict_field(field))
        return declaration_field

    def __init__(self):
        self.data = []
